{"meta":{"title":"网易先知&&网易七鱼前端团队博客","subtitle":null,"description":null,"author":"giflee","url":"http://nsfi.github.io/blog"},"pages":[],"posts":[{"title":"Nodejs实现静态资源服务器","slug":"Nodejs实现静态资源服务器","date":"2017-12-18T03:19:24.000Z","updated":"2018-01-28T08:45:14.000Z","comments":true,"path":"2017/12/18/Nodejs实现静态资源服务器/","link":"","permalink":"http://nsfi.github.io/blog/2017/12/18/Nodejs实现静态资源服务器/","excerpt":"","text":"Nodejs构建静态服务器需要考虑的几个点： 路径分析 不同类型的文件展示 增加文件夹逻辑 形如 ‘http://xxx.com/a/b/‘ , 则查找b目录下是否有index.html,如果有就显示，如果没有就列出该目录下的所有文件及文件夹，并可以进一步访问 增加缓存机制 路由解析123456789const Koa = require('koa')const app = new Koa()app.use( async ( ctx ) =&gt; &#123; console.log(ctx.request.path);&#125;)app.listen(3000);console.log('app started at port 3000 ...'); 纯文本文件查找和读取123456789101112131415161718app.use( ( ctx ) =&gt; &#123; // 拼接出真实路径 let pathName = path.join(staticPath, ctx.request.path); console.log(pathName); // 读取文件 let exist = fs.existsSync(pathName); if (exist === true) &#123; let data = fs.readFileSync(pathName); ctx.response.type = \"html\"; ctx.response.body = data; &#125; else &#123; ctx.response.type = 'text/plain'; ctx.response.body = \"The request URL '\" + pathName + \"' was not found on this server\"; &#125; console.log(exist);&#125;) 不同类型文件的读取MIME值制作映射表MIME.js123456789101112131415161718192021let type = &#123; \"txt\": \"text/plain\", \"xml\": \"text/xml\", \"html\": \"text/html\", \"css\": \"text/css\", \"js\": \"text/javascript\", \"json\": \"application/json\", \"gif\": \"image/gif\", \"png\": \"image/png\", \"jpeg\": \"image/jpeg\", \"jpg\": \"image/jpeg\", \"svg\": \"image/svg+xml\", \"ico\": \"image/x-icon\", \"pdf\": \"application/pdf\", \"swf\": \"application/x-shockwave-flash\", \"tiff\": \"image/tiff\", \"wav\": \"audio/x-wav\", \"wma\": \"audio/x-ms-wma\", \"wmv\": \"video/x-ms-wmv\"&#125;exports.type = type; 通过映射表，根据后缀名来查找 response.type123456const findFileMIME = function (pathName) &#123; // 根据文件后缀名来判断 let filetype = path.extname(pathName).substring(1); if (MIME.type[filetype]) &#123; return MIME.type[filetype]; &#125;&#125; 123let data = fs.readFileSync(pathName);ctx.response.type = findFileMIME(pathName) || 'text';ctx.response.body = data; 完整的文件和文件夹处理12345678910111213141516171819202122232425262728293031323334353637383940const main = async function (ctx, next) &#123; let pathName = path.join(staticPath, ctx.request.path); // 判断文件路径是否存在 let exist = fs.existsSync(pathName); if (exist === true) &#123; // 判断是文件还是文件夹 var stats = fs.statSync(pathName); if (stats.isFile()) &#123; // 如果是文件， 判断文件类型， 并显示文件 let data = fs.readFileSync(pathName); ctx.response.type = findFileMIME(pathName) || 'text'; ctx.response.body = data; &#125; else if (stats.isDirectory()) &#123; // 如果是文件夹, index.html or 文件列表 if (!fs.existsSync(path.join(pathName, 'index.html'))) &#123; // 判断是否存在 index.html ctx.response.type = 'html'; let htmlbody = \"&lt;head&gt;&lt;meta charset = 'utf-8'/&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt;\"; let files = await fs.readdir(pathName); for (let i = 0;i&lt;files.length; i++) &#123; // 排除 DS_STORE 文件 if (files[i]!== '.DS_Store') &#123; let hreflink = path.join(ctx.request.path, files[i]); htmlbody = htmlbody + '&lt;li&gt;&lt;a href=\"' + hreflink +'\"&gt;' + files[i] +'&lt;/a&gt;&lt;/li&gt;'; console.log(path.extname(files[i])); &#125; &#125; htmlbody = htmlbody + '&lt;/ul&gt;&lt;/body&gt;'; ctx.response.body = htmlbody; &#125; else &#123; ctx.response.redirect(path.join(ctx.request.path, 'index.html')); &#125; &#125; &#125; else &#123; ctx.response.type = 'text/plain'; ctx.response.body = \"The request URL '\" + pathName + \"' was not found on this server\"; &#125;&#125;;app.use(main); 增加缓存机制目的：为了缓解请求量增大对服务器的压力，采用缓存机制能够减少对服务器文件的读写。 属性： request If-Modified-Since：第一次请求时response 中的 Last-Modified If-Nont-Match： 浏览器第一次请求时 response 中的 ETag response Cache-Control: max-age=【秒】 || no-cache || no-store || public || private ETag: 当前资源在服务器的唯一标志符 Expires Last-Modified: 告诉浏览器当前资源的最后修改时间 HTTP 缓存策略 本地缓存阶段： 先在本地查找该资源，如果存在，且资源未过期，则使用这一资源，不发送 http 请求到服务器 协商缓存阶段： 如果在本地缓存找到对应资源，但是不知道是否过期，则发一个HTTP请求到服务器，然后服务器判断请求的资源在服务器上是否改动过，没有改动过则返回 304，让浏览器使用本地找到的资源 缓存失败： 当服务器发现请求的资源已经修改过，或这是一个新的请求，服务器则返回该资源的数据，并返回200。如果资源未找到则返回 404 本地缓存阶段 Expires：缓存过期的绝对时间GMT，如果设置了max-age，expires会失效 Cache-Control：max-age=【秒】 前端存储方式 Cookie &lt;4k 且会在同域网络请求中进行传输，消耗网络带宽，大量Cookie会导致请求变慢，所以Cookie只保存与权限有关的用户信息。 LocalStorage 存储非敏感的静态数据 SeesionStorage 关闭浏览器后会清空 协商缓存阶段 Last-Modified === if-modified-since 最后修改时间判断 ETag === If-None-Match 文件的唯一符 协商流程：1、客户端请求一个页面（A）。2、服务器返回页面A，并在给A加上一个Last-Modified/ETag。3、客户端展现该页面，并将页面连同Last-Modified/ETag一起缓存。4、客户再次请求页面A，并将上次请求时服务器返回的Last-Modified/ETag一起传递给服务器。5、服务器检查该Last-Modified或ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304和一个空的响应体。 Etag 主要为了解决 Last-Modified 无法解决的一些问题：1、一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；2、某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；3、某些服务器不能精确的得到文件的最后修改时间。 Content-Length：尽管并没有在缓存中明确涉及，Content-Length头部在设置缓存策略时很重要。某些软件如果不提前获知内容的大小以留出足够空间，则会拒绝缓存该内容。 Vary：缓存系统通常使用请求的主机和路径作为存储该资源的键。当判断一个请求是否是请求同样内容时，Vary头部可以被用来提醒缓存系统需要注意另一个附加头部。它通常被用来告诉缓存系统同样注意Accept-Encoding头部，以便缓存系统能够区分压缩和未压缩的内容。 1234567891011121314151617181920212223242526272829303132333435 // ************ 判断 缓存 ***********************let Expires = &#123; fileMatch: /^(\\.gif|\\.png|\\.jpg|\\.js|\\.css|\\.html)$/ig, maxAge: 60*60&#125;;if (path.extname(ctx.request.path).match(Expires.fileMatch)) &#123; //获取最后修改时间 last-modified var stats = fs.statSync(pathName); let lastModified = stats.mtime.toUTCString(); // last-modified if (ctx.request.header['if-modified-since']) &#123; if (ctx.request.header['if-modified-since'] === lastModified) &#123; ctx.status = 304; await next(); return; &#125; &#125; // ETag if (ctx.request.header['if-none-match']) &#123; if (ctx.request.header['if-none-match'] == lastModified) &#123; ctx.status = 304; await next(); return; &#125; &#125; // cache 失效 fetch new data ctx.set('ETag', lastModified); ctx.set('Last-Modified', lastModified); ctx.status = 200; let data = fs.readFileSync(pathName); ctx.response.type = findFileMIME(pathName) || 'text'; ctx.response.body = data; await next();&#125; 参考资料 缓存策略","categories":[],"tags":[]},{"title":"Less代码规范","slug":"Less代码规范","date":"2017-12-06T08:24:22.000Z","updated":"2017-12-15T02:07:05.000Z","comments":true,"path":"2017/12/06/Less代码规范/","link":"","permalink":"http://nsfi.github.io/blog/2017/12/06/Less代码规范/","excerpt":"","text":"Less代码规范Less代码校验规则遵循stylelint:recommended stylelint:recommended stylelint详细规则 目录 术语 规则声明 选择器 属性 文件分类 命名规则 格式 注释 书写顺序 Less书写顺序 属性书写顺序 最佳实践 典型错误 参考 术语 规则声明我们把一个（或一组）选择器和一组属性称之为 “规则声明”。举个例子： 1234.listing &#123; font-size: 18px; line-height: 1.2;&#125; 选择器在规则声明中，“选择器” 负责选取 DOM 树中的元素，这些元素将被定义的属性所修饰。选择器可以匹配 HTML 元素，也可以匹配一个元素的类名、ID, 或者元素拥有的属性。以下是选择器的例子： 1234567.my-element-class &#123; /* ... */&#125;[aria-hidden] &#123; /* ... */&#125; 属性最后，属性决定了规则声明里被选择的元素将得到何种样式。属性以键值对形式存在，一个规则声明可以包含一或多个属性定义。以下是属性定义的例子： 1234/* some selector */ &#123; background: #f1f1f1; color: #333;&#125; 文件分类页面的样式入口文件按顺序引入以下Less文件。 globals.less 全局文件 components.less 组件 sections.less 区块 main.less 页面主体内容 123456789101112131415/* globals.less */@import \"globals/mixins\";@import \"globals/colors\";@import \"globals/fonts\";/* components.less */@import \"components/tabs\";@import \"components/modals\";/* sections.less */@import \"sections/header\";@import \"sections/footer\";/* main.less */@import \"app/main\"; 命名规则CSS的命名规则 统一处理：建议在这个位置统一调用背景图（这里指多个布局或模块或元件共用的图）和清除浮动（这里指通用性较高的布局、模块、元件内的清除）等统一设置处理的样式！ 布局（grid）（.g-）：将页面分割为几个大块，通常有头部、主体、主栏、侧栏、尾部等！ 模块（module）（.m-）：通常是一个语义化的可以重复使用的较大的整体！比如导航、登录、注册、各种列表、评论、搜索等！ 元件（unit）（.u-）：通常是一个不可再分的较为小巧的个体，通常被重复用于各种模块中！比如按钮、输入框、loading、图标等！ 功能（function）（.f-）：为方便一些常用样式的使用，我们将这些使用率较高的样式剥离出来，按需使用，通常这些选择器具有固定样式表现，比如清除浮动等！不可滥用！ 皮肤（skin）（.s-）：如果你需要把皮肤型的样式抽离出来，通常为文字色、背景色（图）、边框色等，非换肤型网站通常只提取文字色！非换肤型网站不可滥用此类！ 状态（.z-）：为状态类样式加入前缀，统一标识，方便识别，她只能组合使用或作为后代出现（.u-ipt.z-dis{}，.m-list li.z-sel{}），具体详见命名规则的扩展相关项。功能类和皮肤类样式为表现化的样式，请不要滥用！以上顺序可以按需求适当调整。 12345678910111213141516171819202122232425262728293031323334353637383940/* 统一清除浮动 */.g-bdc:after,.m-dimg ul:after,.u-tab:after &#123; display: block; visibility: hidden; clear: both; height: 0; overflow: hidden; content: '.';&#125;.g-bdc,.m-dimg ul,.u-tab &#123; zoom: 1;&#125;/* 布局 */.g-sd &#123; float: left; width: 300px;&#125;/* 模块 */.m-logo &#123; width: 200px; height: 50px;&#125;/* 元件 */.u-btn &#123; height: 20px; border: 1px solid #333;&#125;/* 功能 */.f-tac &#123; text-align: center;&#125;/* 皮肤 */.s-fc,a.s-fc:hover &#123; color: #fff;&#125; 格式 使用 2 个空格作为缩进。 类名建议使用破折号代替驼峰法。 在一个规则声明中应用了多个选择器时，每个选择器独占一行。 在规则声明的左大括号 { 前加上一个空格。 在属性的冒号 : 后面加上一个空格，前面不加空格。 规则声明的右大括号 } 独占一行。 规则声明之间用空行分隔开。 注释 建议使用行注释代替块注释。 建议注释独占一行。避免行末注释。 给没有自注释的代码写上详细说明，比如： 为什么用到了 z-index例如，// modals are 6000, saving messages are 5500, header is 2000 兼容性处理或者针对特定浏览器的 hack 书写顺序 LESS书写顺序 Extend （扩展） Mixins (混合) 常规样式，在extends和mixins之后添加常规样式允许我们正确地覆盖这些属性（如果需要）。 伪元素和伪类样式 嵌套样式1234567891011121314151617.weather &#123; &amp;:extend(.module); .transition(all 0.3s ease-out); background: LightCyan; &amp;:hover &#123; background: DarkCyan; &#125; &amp;::before &#123; content: \"\"; display: block; &#125; &gt; h3 &#123; .transform(rotate(90deg)); border-bottom: 1px solid white; &#125; ...&#125; 属性书写顺序 → 显示属性 自身属性 文本属性和其他修饰 display width font visibility height text-align position margin text-decoration float padding vertical-align clear border white-space list-style overflow color top min-width background 最佳实践 使用变量命名常用的数字和颜色 典型错误 不要使用 ID 选择器。 不要使用!important 不要使用浏览器私有前缀，使用autoprefixer替代。 嵌套选择器的深度不要超过 3 层！ 1234567.page-container &#123; .content &#123; .profile &#123; // STOP! &#125; &#125;&#125; 不要使用class作为javascript钩子，在react中可使用refs替代javascript钩子。 嵌套选择器的行数不要超过 50 行! 参考 Airbnb CSS / Sass 指南 Netease CSS规范 Sass Style Guide","categories":[],"tags":[]},{"title":"如何发表文章","slug":"Quick-Start","date":"2017-11-20T07:41:32.000Z","updated":"2017-12-15T02:07:05.000Z","comments":true,"path":"2017/11/20/Quick-Start/","link":"","permalink":"http://nsfi.github.io/blog/2017/11/20/Quick-Start/","excerpt":"","text":"快速开始获取源码代码托管在NSFI组下的sf-blog-source中 1$ git clone https://github.com/NSFI/sf-blog-source.git 安装依赖1$ npm install 创建文章1$ hexo new '文章title' 本地服务预览1$ hexo server 生成静态文件1$ hexo g 部署到服务器1$ hexo d 为了保证统一，部署之前最好将代码推到github库中去以后再执行hexo d。 More info: hexo文档","categories":[],"tags":[{"name":"how to use","slug":"how-to-use","permalink":"http://nsfi.github.io/blog/tags/how-to-use/"}]}]}